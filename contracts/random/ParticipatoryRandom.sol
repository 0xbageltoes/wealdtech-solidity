pragma solidity ^0.4.21;

// Copyright Â© 2018 Weald Technology Trading Limited
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * @title ParticipatoryRandom
 *        ParticipatoryRandom allows the creation of multiple random numbers
 *        through the use of repeated hashing of a seed, and combination of
 *        values from multiple participants.  Verification of values can be
 *        carried out on-chain if required.
 *
 *        The ParticipatoryRandom contract works on instances.  Anyone can
 *        create an instance with `newInstance()`, supplying the maximum number
 *        of rounds for which the instance can supply random numbers.  Each
 *        participant generates a source value off-chain from private seeds,
 *        either through the `generateSourceFromSeed()` function or equivalent
 *        code, and presents it to the contract with `setSource()`.
 *
 *        Once all participants have logged a source the random number
 *        generation may begin.  For round `n` each participant generates their
 *        value off-chain using `generateValueFromSeed()` and makes the
 *        resultant value available to all other participants.  All
 *        participants then generates the random value off-chain using
 *        `generateRandomValue()`, providing the agreed-upon random value for
 *        that round.
 *
 * @author Jim McDonald
 * @notice If you use this contract please consider donating some Ether or
 *         some of your ERC-20 token to wsl.wealdtech.eth to support continued
 *         development of these and future contracts
 */
contract ParticipatoryRandom {
    // Number of rounds per instance
    mapping(uint256=>uint256) rounds;
    // Sources for each participant in an instance
    mapping(uint256=>mapping(address=>bytes32)) sources;

    event NewInstance(uint256 instanceId, uint256 rounds);

    /**
     * newInstance creates a new instance for participants to join
     * @param _instanceId the ID of the instance to create.
     * @param _rounds the number of rounds for which each seed is valid.
     */
    function newInstance(uint256 _instanceId, uint256 _rounds) public {
        require(_instanceId != 0);
        require(rounds[_instanceId] == 0);
        rounds[_instanceId] = _rounds;
        emit NewInstance(_instanceId, _rounds);
    }

    /**
     * getInstanceMaxRounds returns the maximum number of rounds for which an
     * instance can generate random numbers.  Any attempt to generate random
     * numbers for a round higher than this will fail.
     * @param _instanceId the ID of the instance.
     * @return the maximum number of rounds for the instance.
     */
    function getInstanceMaxRounds(uint256 _instanceId) public view returns (uint256) {
        require(_instanceId != 0);
        require(rounds[_instanceId] != 0);
        return rounds[_instanceId];
    }

    /**
     * generateSourceFromSeed generates the source for a given seed.  This
     * function should only ever be run off-chain; the resultant value can be
     * supplied to an instantiation of this contract with SetSource().
     * @param _instanceId the ID of the instance.
     * @param _seed the seed for the random numbers.
     * @return the source to be supplied to SetSource.
     */
    function generateSourceFromSeed(uint256 _instanceId, bytes32 _seed) public view returns (bytes32) {
        require(rounds[_instanceId] != 0);
        bytes32 source = _seed;
        for (uint256 i = 0; i <= rounds[_instanceId]; i++) {
            source = keccak256(source);
        }
        return source;
    }

    /**
     * setSource sets the source for a given user
     * @param _instanceId the ID of the instance.
     * @param _source the source as generated by `generateSourceFromSeed()`
     */
    function setSource(uint256 _instanceId, bytes32 _source) public {
        require(rounds[_instanceId] != 0);
        require(sources[_instanceId][msg.sender] == 0);
        sources[_instanceId][msg.sender] = _source;
    }

    /**
     * generateValueFromSeed generates the value for a given seed at a given
     * round.  This function should only every be run off-chain; the resultant
     * value can be used
     * @param _instanceId the ID of the instance.
     * TODO params, return
     */
    function generateValueFromSeed(uint256 _instanceId, bytes32 _seed, uint256 _round) public view returns (bytes32) {
        require(rounds[_instanceId] != 0);
        require(_round > 0);
        require(_round <= rounds[_instanceId]);
        bytes32 value = _seed;
        for (uint256 i = 0; i <= (rounds[_instanceId]-_round); i++) {
            value = keccak256(value);
        }
        return value;
    }

    /**
     * validateValue checks the validity of a value supplied by a gien party
     * for a given round.  This should be run off-chain prior to using a value.
     * @param _instanceId the ID of the instance.
     * @param _party the address of the party that supplied the value.
     * @param _round the round for which the generation is taking place.
     * @param _value the value that the party supplied.
     * @return true if the value is valid, otherwise false.
     */
    function validateValue(uint256 _instanceId, address _party, uint256 _round, bytes32 _value) public view returns (bool) {
        require(rounds[_instanceId] != 0);
        require(_round > 0);
        require(_round <= rounds[_instanceId]);
        bytes32 value = _value;
        for (uint256 i = _round; i > 0; i--) {
            value = keccak256(value);
        }
        return (value == sources[_instanceId][_party]);
    }

    /**
     * generateRandomValue generates a random value for an instance given the
     * round number, the addresses of the participants and their individual
     * values.
     *
     * If any of the values supplied are invalid then this will revert.  As
     * such, if it returns then the value can be considered trusted.
     * 
     * @param _instanceId the ID of the instance.
     * @param _parties the address of the parties that supply the values.
     * @param _round the round for which the generation is taking place.
     * @param _values the values supplied by the parties.
     * @return the random value.
     */
    function generateRandomValue(uint256 _instanceId, address[] _parties, uint256 _round, bytes32[] _values) public view returns (bytes32) {
        require(rounds[_instanceId] != 0);
        require(_round > 0);
        require(_round <= rounds[_instanceId]);
        require(_parties.length > 0);
        require(_parties.length == _values.length);
        require(validateValue(_instanceId, _parties[0], _round, _values[0]));
        bytes32 value = _values[0];
        for (uint256 i = 1; i < _parties.length; i++) {
            require(validateValue(_instanceId, _parties[i], _round, _values[i]));
            value = value ^ _values[i];
        }
        return value;
    }
}

